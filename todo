#phase 2

recipes: booleano se faz c√°lculos autom√°ticos
			\-> se verdadeiro, faz soma das linhas e mete os campos a readonly (s√≥ podendo alterar as unidades, os restantes (calorias e peso) s√£o calculados automaticamente[qtx*soma de cada 1 dos artigos])
			\-> se for falso, √© de edi√ß√£o livre (mas os c√°lculos automaticos como temos nos produtos e entidades tambem se aplica )

recipes: terminar css

recipemats: qtd by weight -> adicionar booleano em bd -> na ficha de artigo ou na ficha da linha?
recipemats: adicionar calculos automaticos -> vers√£o lite (conforme descrito abaixo), existindo um campo readonly/snapshot para auxilio (p.e. mostra o peso ou quantidade, de acordo com o que o utilizador N√£o utilizar)
			\-> se recipe tiver calculo automatico, atualizar o seu valor ao gravar uma linha de material

recipemats: utilizar contexto para alterar o titulo do dialog





0. no records: desenhar kind of 404 friendly, com op√ß√£o para adicioanr novo registo
(verificar com o backend se ele nao dispara erro quando n√£o encontra nenhum [pode nao encontrar, visto se nao existir])

1. receitas -> lista de produtos/suplementos que incluem a receita
	\-> nova entidade invisivel -> recipelines
		\-> criar interface generica - IRecipeLine (composta pelas propriedads comuns aos suplementos e produtos [√© quase tudo mas whatever, futureproofing])
			\-> stamp: stamp da linha
			\-> product/supplementstamp: stamp do artigo original





	modal da receita:

	SELECT title,product/supplementstamp from recipelines WHERE recipestamp = 'XXX'


	modo de edi√ß√£o:

	criar um array de form groups, 1 para cada produto da receitra
	os formgroups sao todos iguais

	para introduzir, temos 2 bot√µes, 1 adiciona uma linha de suplemento, outro uma linha de produto
	cada tipo de linha faz query apenas √° respetiva entidade

	ao selecionar o artigo, temos um tipo de booleano: quantidade, peso/mliq, que serve para controlar o metodo de introdu√ß√£o na receita (por quantidade ou peso)

		\-> caso quantidade

		\-> quantidade | calorias | pre√ßo			v- hardcoded (1 unidade)   (unitvalue)<- readonly
			\-> defaults com os valores do registo (1, kcal e price do registo)
			\-> ao alterar quantidade:
				new calorias = old calorias / old quantidadae * new quantidade
				new pre√ßo = old pre√ßo / old quantidadae * new quantidade
				new unitvalue = old unitvalue / old quantidadae * new quantidade
				-- no cabe√ßalho da receita, atualizar sumat√≥rio de kcals, pre√ßo e peso (unitvalue)
			\-> ao alterar calorias
				-- no cabe√ßalho da receita, atualizar sumat√≥rio de kcals
			\-> ao alterar pre√ßo
				-- no cabe√ßalho da receita, atualizar sumat√≥rio de pre√ßo

		\-> caso peso/liq

		\->quantidade | calorias | pre√ßo
			\-> defaults com os valores do registo (unitvalue, kcal e price do registo)
			\-> ao alterar quantidade:
				new calorias = old calorias / old quantidadae * new quantidade
				new pre√ßo = old pre√ßo / old quantidadae * new quantidade
				-- no cabe√ßalho da receita, atualizar sumat√≥rio de kcals, pre√ßo e peso
			\-> ao alterar calorias
				-- no cabe√ßalho da receita, atualizar sumat√≥rio de kcals
			\-> ao alterar pre√ßo
				-- no cabe√ßalho da receita, atualizar sumat√≥rio de pre√ßo

		sumatorios cabe√ßalho: kcals de todos, pre√ßo de todos, calorias de todos, unitvalue dos caso quantidade, quantidade caso peso/liquido
			\-> calculo automatico "a la produtos"



	¬ª¬ª¬ª fastfoward, no ecr√£ de refei√ß√£o, vamos ter a mesma grelha, s√≥ que desta vez temos uma terceira maneira de adicionar (tinhamos suplemento, produto, e agora temos receita)




3. stocks - > movimentos de stocks
	\-> ao introduzir,

	1. d√° para escolher que tipo de movimento √©:
		1- saldo inicial
		2- compra
		3- consumo
		4- corre√ß√£o

	2. scolhemos da lista de suplementos o suplemento a coize

	3. definir quantidades de sa√≠da / entrada

	4. data da entrada / saida

	5. titulo : prenchido automaticamente com o nome da refei√ß√£o no caso de consumo; else √© free


	campos:
	stamp
	type
	supplementstamp
	qtdin
	qtdout
	date
	title


	na modal do suplemento
	query de stocks:
	SELECT (SUM(qtdin) - SUM(qtdout)) as stock FROM supplements WHERE supplementstamp = 'XXX'


	query de receitas:
		-> tenho de ir buscar o recipestamp das recipelines que tenham o supplementstamp
	@Stamps = SELECT recipestamp from recipelines WHERE supplementstamp = 'XXX'
	SELECT title,stamp from recipes WHERE stamp in @Stamps




4. refei√ß√£o (ecr√£ c/c)

	cabe√ßalho: titulo
	date:
	tipo: p.e. pequeno almo√ßo, jantar
	pre√ßo (sem pre√ßo / kg/l):
	kcal (sem kcal / 100):

	grelha de linhas:
	-> ao introduzir, vai lan√ßar em stock (apenas suplementos e receitas c/suplementos)
	-> d√° para introduzir produtos, receitas e suplementos
	-> faz aqueles calculos malucos como no ecr√£ de receitas








campos:
- stamp
- supplementstamp
- qtd in
- qtd out
- data
- descri√ß√£o -> nome da refei√ß√£o
- categoria [enum proprio: 1-Entrada (compra/saldo inicial), 2-Sa√≠da (consumo), 3-Corre√ß√£o (perdas)]



# ts
2. material paginator language
3. 4th mat color (sucess/green)

# css / html
1. tabela produtos main-form (modo lista)
2. :hover image picker redo

# mobile
1. componentes pr√≥prios para formfield com inputs a la bootstrap, para dar resposta para vista mobile
2. vista mobile nos restantes componentes

# php
1. refract php (LeggeraError/LeggeraSucess > login/cookie login)
2. password hash and salt

# hybrid
1. product - last consumed

# whiteboard
1. shared products brainstorm ‚úÖ
  \-> flag invisivel que serve apenas para fornecer ao utilizador os produtos default.
  \-> o utilizador pode esconder todos, e duplicar. nao pode apagar nem editar.
  \-> futuramente ao tratar da entidade de consumos, o utilizador logo pode alterar os valores que preferir.
  \-> estes valores s√£o guardados apenas numa coluna na tabela de consumos, no formato json[worst case, fazer mais uma tabela, consumos lines ]

2. inactive products brainstorm ‚úÖ
  \-> flag que serve para esconder o produto dos autocompletes de receitas e consumos
  \-> posso deixar apagar qualquer registo. como na cole√ß√£o dos consumos tenho os detalhes que preciso e o stamp original, sempre que consultar um consumo com um registo apagado (tenmho de fazer query para ir ler aimagem) dou disable √° navega√ß√£o e mostro uma imagem generica (posso tambem mostrar um badge so naquela just like)

3. simple search ‚úÖ
	3.1 - adicionar mais campos para procura exata

				SELECT * FROM PRODUCTS WHERE
					COL1 = X OR COL2 = X OR COL3 = X OR COL[unitvalue] = X


	3.2. - turbinar procura simples
	\-> fazemos slice ao input (transformar em array)
	\-> executar uma segunda query, na qual o array de slices √© uma AND clause

				SELECT * FROM PRODUCTS WHERE
					COL1 = X OR COL2 = X OR COL3 = X
					AND
					COL1 = Y OR COL2 = Y OR COL3 = Y
					AND
					COL1 = Z OR COL2 = Z OR COL3 = Z

	\-> fazer uni√£o com distinct das queries 3.1 e 3.2

# menus yet to build
* dashboard - mostra v√°rios cart√µes de evolu√ß√µes (peso do user, peso que consegue levantar no exerc√≠cio X, √∫ltima vez que fez o exerc√≠cio Y, √∫ltima vez que comeu K, etc etc etc...)
* bobybuilding - regimes - template de dias detalhados de treinos + suplementa√ß√£o (a 7, 14 ou 28 dias)
* calendario - vista geral - mostra alimenta√ß√µes (imagem das categorias de piteu consumido), suplementa√ß√£o (imagens do tipo de suplementa√ß√£o) e muscula√ß√£o (imagens das categorias de musculos)
* calend√°rio - evolu√ß√£o - track di√°rio de peso (registos √° la c/c)
* par√¢metros - utilizador e app



# v2
* advanced search -

# mainform produtos
1. redo campos nutricionais e pre√ßo:

	unidade de medida üöß -> s√≥ pode ser gramas, ou millilitros
	valor unidade de medida üöß - > peso/volume de 1 qtd
	Kcal üöß
		\-> kcal de 1 qtd
		\-> kcal 100g / 100ml   (ao preencher 1, calcula o outro)
	Pre√ßo üöß
		\-> ‚Ç¨ por qtd
		\-> ‚Ç¨ por Kg / Lt       (ao preencher 1, calcula o outro)


		details:

		[valor][unidade]
		kcal / qtd (kcal/100 invi)
		pre√ßo unit:    ||      pre√ßo kg
									^ booleano na ficha de artigo (exibir pre√ßo alternativo)



1.2
	ao utilizar o produto, escolho se consumi qtd ou gramas/millilitros



